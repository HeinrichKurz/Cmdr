"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[77],{91964:e=>{e.exports=JSON.parse('{"functions":[{"name":"RegisterType","desc":"Registers a type on the current realm (server/client), this function should be called from within the type definition ModuleScript.","params":[{"name":"name","desc":"The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit.","lua_type":"string"},{"name":"typeObject","desc":"","lua_type":"TypeDefinition"}],"returns":[],"function_type":"method","source":{"line":184,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterTypePrefix","desc":"Registers a Prefixed Union Type string on the current realm (server/client), this function should be called from within the type definition ModuleScript.\\n\\nIf there are already type prefixes for the given type name, they will be concatenated. This allows you to add prefixes to default types, like `players`.","params":[{"name":"name","desc":"The name of the type.","lua_type":"string"},{"name":"union","desc":"The string should omit the initial type name, so this string should begin with a prefix character, e.g. `# integer ! boolean`","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":224,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterTypeAlias","desc":"Allows you to register a name which will be expanded into a longer type which can be used as a command argument type.\\nFor example, if you register the alias `stringOrNumber` it could be interpreted as `string # number` when used.","params":[{"name":"name","desc":"The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit.","lua_type":"string"},{"name":"alias","desc":"The string should *include* the initial type name, e.g. `string # integer ! boolean`","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":240,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterTypesIn","desc":"Registers all types from within a container on both the server and client.","params":[{"name":"container","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":251,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterHooksIn","desc":"Registers all hooks from within a container on both the server and client.\\nIf you want to add a hook only on the server or client \u2013 e.g. for logging \u2013 then you should use the Register.RegisterHook method instead.","params":[],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":272,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterCommandObject","desc":"Register a command purely based on its definition.\\nPrefer using Registry:RegisterCommand for proper handling of client/server model.","params":[{"name":"commandObject","desc":"","lua_type":"CommandDefinition"}],"returns":[],"function_type":"method","private":true,"source":{"line":282,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterCommand","desc":"Registers a command definition and its server equivalent. Handles replicating the definition to the client.","params":[{"name":"commandScript","desc":"","lua_type":"ModuleScript"},{"name":"commandServerScript","desc":"","lua_type":"ModuleScript?"},{"name":"filter","desc":"If present, will be passed a command definition which will then only be registered if the function returns `true`.","lua_type":"(CommandDefinition -> boolean)?"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":335,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterCommandsIn","desc":"Registers all commands from within a container on both the server and client.\\n\\nModule scripts which include `Server` in their name will not be sent to the client.","params":[{"name":"container","desc":"","lua_type":"Instance"},{"name":"filter","desc":"If present, will be passed a command definition which will then only be registered if the function returns `true`.","lua_type":"((CommandDefinition) -> boolean)?"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":370,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterDefaultCommands","desc":"Registers the default commands on both the server and client.\\n\\nThe optional `arrayOrFunc` parameter can be provided with:\\n\\n1. an array of strings \u2014 this will limit registration to only commands which have their `Group` property set to this\\n2. a function which takes in a CommandDefinition and returns a `boolean` \u2014 only if `true` is returned will the command be registered","params":[{"name":"arrayOrFunc","desc":"","lua_type":"{string} | (CommandDefinition) -> boolean | nil"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":414,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetCommand","desc":"Returns the CommandDefinition from the given name, or nil if no command is found. Command aliases are also accepted.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"CommandDefinition?"}],"function_type":"method","source":{"line":429,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetCommands","desc":"Returns an array of all registers commands, not including aliases.","params":[],"returns":[{"desc":"","lua_type":"{CommandDefinition}"}],"function_type":"method","source":{"line":439,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetCommandNames","desc":"Returns an array of containing the names of all registered commands, not including aliases.","params":[],"returns":[{"desc":"","lua_type":"{ string }\\r\\n"}],"function_type":"method","source":{"line":447,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetCommandsAsStrings","desc":"","params":[],"returns":[],"function_type":"method","deprecated":{"version":"v1.8.0","desc":"This method was renamed to GetCommandNames in v1.8.0. The old name exists for backwards compatibility and should not be used for new work."},"source":{"line":462,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetTypeNames","desc":"Returns an array of containing the names of all registered types, not including aliases.","params":[],"returns":[{"desc":"","lua_type":"{ string }\\r\\n"}],"function_type":"method","source":{"line":468,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetType","desc":"Returns the type definition from the given name, or nil if no argument is found.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"TypeDefinition?"}],"function_type":"method","source":{"line":483,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetTypeName","desc":"Returns a type name taking aliases into account. If there is no alias, the name parameter is simply returned as a pass through.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"TypeDefinition | string"}],"function_type":"method","source":{"line":492,"path":"Cmdr/Shared/Registry.lua"}},{"name":"RegisterHook","desc":"Registers a hook on the current realm (server/client). This should probably be ran on the server or in a hook module script, but can also work on the client.\\n\\nHooks run in order of priority from lowest (running first) to highest.","params":[{"name":"hookName","desc":"","lua_type":"HookType"},{"name":"callback","desc":"returns nil for ok, string (errorText) for cancellation","lua_type":"(CommandContext) -> string?"},{"name":"priority","desc":"If unspecified, the priority will default to `0`.","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":506,"path":"Cmdr/Shared/Registry.lua"}},{"name":"AddHook","desc":"","params":[{"name":"hookName","desc":"","lua_type":"HookType"},{"name":"callback","desc":"returns nil for ok, string (errorText) for cancellation","lua_type":"(CommandContext) -> string?"},{"name":"priority","desc":"If unspecified, the priority will default to `0`.","lua_type":"number"}],"returns":[],"function_type":"method","deprecated":{"version":"v1.1.2","desc":"This method was renamed to RegisterHook in v1.1.2. The old name exists for backwards compatibility and should not be used for new work."},"source":{"line":525,"path":"Cmdr/Shared/Registry.lua"}},{"name":"GetStore","desc":"Returns a table saved with the given name. Always returns the same table on subsequent calls. Useful for commands that require persistent state, like bind or ban.\\nThis is the same as CommandContext.GetStore.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"method","source":{"line":533,"path":"Cmdr/Shared/Registry.lua"}},{"name":"FlushAutoExecBufferDeferred","desc":"Calls Registry.FlushAutoExecBuffer at the end of the frame.","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":542,"path":"Cmdr/Shared/Registry.lua"}},{"name":"FlushAutoExecBuffer","desc":"Runs all pending auto exec commands in Registry.AutoExecBuffer.","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":559,"path":"Cmdr/Shared/Registry.lua"}}],"properties":[{"name":"TypeMethods","desc":"","lua_type":"{ [string]: true }","private":true,"readonly":true,"source":{"line":63,"path":"Cmdr/Shared/Registry.lua"}},{"name":"CommandMethods","desc":"","lua_type":"{ [string]: true }","private":true,"readonly":true,"source":{"line":70,"path":"Cmdr/Shared/Registry.lua"}},{"name":"CommandArgProps","desc":"","lua_type":"{ [string]: true }","private":true,"readonly":true,"source":{"line":77,"path":"Cmdr/Shared/Registry.lua"}},{"name":"Types","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":84,"path":"Cmdr/Shared/Registry.lua"}},{"name":"TypeAliases","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":91,"path":"Cmdr/Shared/Registry.lua"}},{"name":"Commands","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":98,"path":"Cmdr/Shared/Registry.lua"}},{"name":"CommandsArray","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":105,"path":"Cmdr/Shared/Registry.lua"}},{"name":"Cmdr","desc":"A reference to Cmdr. This may either be the server or client version of Cmdr depending on where the code is running.","lua_type":"Cmdr | CmdrClient","readonly":true,"source":{"line":112,"path":"Cmdr/Shared/Registry.lua"}},{"name":"Hooks","desc":"","lua_type":"{ [HookType]: table }","private":true,"readonly":true,"source":{"line":119,"path":"Cmdr/Shared/Registry.lua"}},{"name":"Stores","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":126,"path":"Cmdr/Shared/Registry.lua"}},{"name":"AutoExecBuffer","desc":"","lua_type":"table","private":true,"readonly":true,"source":{"line":133,"path":"Cmdr/Shared/Registry.lua"}}],"types":[{"name":"HookType","desc":"","lua_type":"\\"BeforeRun\\" | \\"AfterRun\\"","source":{"line":15,"path":"Cmdr/Shared/Registry.lua"}},{"name":"ArgumentDefinition","desc":"The `table` definition, usually contained in a [CommandDefinition](#CommandDefinition), which \'defines\' the argument.","fields":[{"name":"Type","lua_type":"string | TypeDefinition","desc":"The argument type (case sensitive), or an [inline TypeDefinition object](/docs/commands#dynamic-arguments-and-inline-types)."},{"name":"Name","lua_type":"string","desc":"The argument name, this is displayed to the user as they type."},{"name":"Description","lua_type":"string?","desc":"A description of what the argument is, this is also displayed to the user."},{"name":"Optional","lua_type":"boolean?","desc":"If this is set to `true`, then the user can run the command without filling out the value. In which case, the argument will be sent to implementations as `nil`."},{"name":"Default","lua_type":"any?","desc":"If present, the argument will be automatically made optional, so if the user doesn\'t supply a value, implementations will receive whatever the value of `Default` is."}],"source":{"line":27,"path":"Cmdr/Shared/Registry.lua"}},{"name":"CommandDefinition","desc":"","fields":[{"name":"Name","lua_type":"string","desc":"The name of the command"},{"name":"Aliases","lua_type":"{string}?","desc":"Aliases which aren\'t part of auto-complete, but if matched will run this command just the same. For example, `m` might be an alias of `announce`."},{"name":"Description","lua_type":"string?","desc":"A description of the command, displayed to the user in the `help` command and auto-complete menu."},{"name":"Group","lua_type":"string?","desc":"This property is intended to be used in hooks, so that you can categorise commands and decide if you want a specific user to be able to run them or not. But the `help` command will use them as headings."},{"name":"Args","lua_type":"{ArgumentDefinition | (CommandContext) -> (ArgumentDefinition)}","desc":"Arguments for the command; this is technically optional but if you have no args, set it to `{}` or you may experience some interface weirdness."},{"name":"Data","lua_type":"(CommandContext, ...) -> any","desc":"If your command needs to gather some extra data from the client that\'s only available on the client, then you can define this function. It should accept the command context and tuple of transformed arguments, and return a single value which will be available in the command with [CommandContext:GetData](/api/CommandContext#GetData)."},{"name":"ClientRun","lua_type":"(CommandContext, ...) -> string?","desc":"If you want your command to run on the client, you can add this function to the command definition itself. It works exactly like the function that you would return from the Server module. If this function returns a string, the command will run entirely on the client and won\'t touch the server (which means server-only hooks won\'t run). If this function doesn\'t return anything, it will fall back to executing the Server module on the server."},{"name":"Run","lua_type":"(CommandContext, ...) -> string?","desc":"An older version of ClientRun. There are very few scenarios where this is preferred to ClientRun (so, in other words, don\'t use it!). These days, `Run` is only used for some dark magic involving server-sided command objects."}],"source":{"line":40,"path":"Cmdr/Shared/Registry.lua"}},{"name":"TypeDefinition","desc":"The `table` definition, contained in an [ArgumentDefinition](#ArgumentDefinition) or [registered](#RegisterType), which \'defines\' the argument.","fields":[{"name":"Prefixes","lua_type":"string?","desc":"String containing [prefixed union types](/docs/commands#prefixed-union-types) for this type. This property should omit the inital type, so the string should begin with a prefix character, e.g. `Prefixes = \\"# integer ! boolean\\"`"},{"name":"DisplayName","lua_type":"string?","desc":"Overrides the user-facing name of this type in the autocomplete menu. Otherwise, the registered name of the type will be used."},{"name":"Default","lua_type":"((Player) -> string)?","desc":"Should return the \\"default\\" value for this type as a string. For example, the default value of the `player` type is the name of the player who ran the command."},{"name":"Listable","lua_type":"boolean?","desc":"If true, this will tell Cmdr that comma-separated lists are allowed for this type. Cmdr will automatically split the list and parse each segment through your `Transform`, `Validate`, `Autocomplete` and `Parse` functions individually, so you don\'t have to change the logic of your type at all. The only limitation is that your `Parse` function **must return a table**, the tables from each individual segment\'s `Parse` functions will be merged into one table at the end of the parsing step. The uniqueness of values is ensured upon merging, so even if the user lists the same value several times, it will only appear once in the final table."},{"name":"Transform","lua_type":"(string, Player) -> T?","desc":"Transform is an optional function that is passed two values: the raw text, and the player running the command. Then, whatever values this function returns will be passed to all other functions in the type (`Validate`, `Autocomplete` and `Parse`)."},{"name":"Validate","lua_type":"(T) -> (boolean, string?)","desc":"The `Validate` function is passed whatever is returned from the `Transform` function (or the raw value if there is no `Transform` function). If the value is valid for the type, it should return `true`. If the value is invalid, it should return two values: `false` and a string containing an error message. If this function is omitted, anything will be considered valid."},{"name":"ValidateOnce","lua_type":"(T) -> (boolean, string?)","desc":"This function works exactly the same as the normal `Validate` function, except it only runs once (after the user presses Enter). This should only be used if the validation process is relatively expensive or needs to yield. For example, the `playerId` type uses this because it needs to call `GetUserIdFromNameAsync` in order to validate. For the vast majority of types, you should just use `Validate` instead."},{"name":"Autocomplete","lua_type":"(T) -> ({string}, {IsPartial: boolean?}?)?","desc":"Should only be present for types that are possible to be auto-completed. It should return an array of strings that will be displayed in the auto-complete menu. It can also return a second value, containing a dictionary of options (currently, `IsPartial`: if true then pressing Tab to auto-complete won\'t continue onwards to the next argument.)"},{"name":"Parse","lua_type":"(T) -> any","desc":"Parse is the only required function in a type definition. It is the final step before the value is considered finalised. This function should return the actual parsed value that will be sent to implementations."}],"source":{"line":56,"path":"Cmdr/Shared/Registry.lua"}}],"name":"Registry","desc":"The registry keeps track of all the commands and types that Cmdr knows about.","source":{"line":10,"path":"Cmdr/Shared/Registry.lua"}}')}}]);