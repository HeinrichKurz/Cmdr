[{"title":"Best practice","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/advanced/bestpractice","content":"Best practice Work in progress We're sorry but this article has yet to be written.","keywords":""},{"title":"CmdrClient","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/CmdrClient","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#properties","content":" "},{"title":"Registry​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.Registry: Registry Refers to the current command Registry.  "},{"title":"Dispatcher​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Dispatcher","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.Dispatcher: Dispatcher Refers to the current command Dispatcher.  "},{"title":"Util​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.Util: Util Refers to a table containing many useful utility functions.  "},{"title":"Enabled​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Enabled","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.Enabled: boolean Whether or not Cmdr is enabled (will show via the defined activation keys). Use CmdrClient:SetEnabled to change.  "},{"title":"PlaceName​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#PlaceName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.PlaceName: string The current place name, displayed on the interface. Use CmdrClient:SetPlaceName to change.  "},{"title":"ActivationKeys​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#ActivationKeys","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrClient.ActivationKeys: {[Enum.KeyCode]=true} The list of key codes that will show or hide Cmdr. Use CmdrClient:SetActivationKeys to change. "},{"title":"Functions​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#functions","content":" "},{"title":"SetActivationKeys​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetActivationKeys","content":"&lt;/&gt; CmdrClient:SetActivationKeys(keys: {Enum.KeyCode}) → () Sets the key codes that will used to show or hide Cmdr.  "},{"title":"SetPlaceName​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetPlaceName","content":"&lt;/&gt; CmdrClient:SetPlaceName(name: string) → () Sets the place name label on the interface. This is useful for a quick way to tell what game you're playing in a universe game.  "},{"title":"SetEnabled​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetEnabled","content":"&lt;/&gt; CmdrClient:SetEnabled(enabled: boolean) → () Sets whether or not Cmdr can be shown via the defined activation keys. Useful for when you want users to opt-in to show the console, for instance in a settings menu.  "},{"title":"SetActivationUnlocksMouse​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetActivationUnlocksMouse","content":"&lt;/&gt; CmdrClient:SetActivationUnlocksMouse(enabled: boolean) → () Sets if activation will free the mouse.  "},{"title":"Show​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Show","content":"&lt;/&gt; CmdrClient:Show() → () Shows the Cmdr window. Does nothing if Cmdr isn't enabled.  "},{"title":"Hide​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Hide","content":"&lt;/&gt; CmdrClient:Hide() → () Hides the Cmdr window.  "},{"title":"Toggle​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#Toggle","content":"&lt;/&gt; CmdrClient:Toggle() → () Toggles the Cmdr window. Does nothing if Cmdr isn't enabled.  "},{"title":"SetMashToEnable​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetMashToEnable","content":"&lt;/&gt; CmdrClient:SetMashToEnable(enabled: boolean) → () Enables the &quot;Mash to open&quot; feature. This feature, when enabled, requires the activation key to be pressed 5 times within a second to enable Cmdr. This may be helpful to guard against mispresses from opening the window, for example.  "},{"title":"SetHideOnLostFocus​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#SetHideOnLostFocus","content":"&lt;/&gt; CmdrClient:SetHideOnLostFocus(enabled: boolean) → () Sets the hide on 'lost focus' feature. This feature, which is enabled by default, will cause Cmdr to hide when the user clicks off the window.  "},{"title":"HandleEvent​","type":1,"pageTitle":"CmdrClient","url":"/Cmdr/beta/api/CmdrClient#HandleEvent","content":"&lt;/&gt; CmdrClient:HandleEvent( name: string, callback: (...any) → () ) → () Sets the network event handler for a certain event type. "},{"title":"ArgumentContext","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/ArgumentContext","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#properties","content":" "},{"title":"Command​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Command","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Command: CommandContext The command that this argument belongs to.  "},{"title":"Type​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Type","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Type: TypeDefinition The type definition for this argument.  "},{"title":"Name​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Name: string The name of this argument, shown on the autocomplete interface.  "},{"title":"Object​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Object","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Object: ArgumentDefinition The raw argument definition.  "},{"title":"Required​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Required","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Required: boolean Whether or not this argument was required.  "},{"title":"Executor​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Executor","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Executor: Player  The player that ran the command that this argument belongs to.  "},{"title":"RawValue​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#RawValue","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.RawValue: string The raw, unparsed value for this argument.  "},{"title":"RawSegments​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#RawSegments","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.RawSegments: {string} An array of strings representing the values in a comma-separated list, if applicable.  "},{"title":"Prefix​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#Prefix","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Prefix: string The prefix used in this argument (like % in %Team). Empty string if no prefix was used. See Prefixed Union Types for more details. "},{"title":"Functions​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#functions","content":" "},{"title":"GetTransformedValue​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#GetTransformedValue","content":"&lt;/&gt; ArgumentContext:GetTransformedValue(segment: number) → ...any Returns the transformed value from this argument, see Types.  "},{"title":"GetValue​","type":1,"pageTitle":"ArgumentContext","url":"/Cmdr/beta/api/ArgumentContext#GetValue","content":"&lt;/&gt; ArgumentContext:GetValue() → any Returns the parsed (final) value for this argument. "},{"title":"Cmdr","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/Cmdr","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Cmdr","url":"/Cmdr/beta/api/Cmdr#properties","content":" "},{"title":"Registry​","type":1,"pageTitle":"Cmdr","url":"/Cmdr/beta/api/Cmdr#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Cmdr.Registry: Registry Refers to the current command Registry.  "},{"title":"Dispatcher​","type":1,"pageTitle":"Cmdr","url":"/Cmdr/beta/api/Cmdr#Dispatcher","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Cmdr.Dispatcher: Dispatcher Refers to the current command Dispatcher.  "},{"title":"Util​","type":1,"pageTitle":"Cmdr","url":"/Cmdr/beta/api/Cmdr#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Cmdr.Util: Util Refers to a table containing many useful utility functions. "},{"title":"CommandContext","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/CommandContext","content":"On this page CommandContext Represents an individual command execution. Beta This page is incomplete. You might want to refer to the current documentation.","keywords":""},{"title":"Dispatcher","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/Dispatcher","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#properties","content":" "},{"title":"Cmdr​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#Cmdr","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Dispatcher.Cmdr: Cmdr | CmdrClient A reference to Cmdr. This may either be the server or client version of Cmdr depending on where the code is running.  "},{"title":"Registry​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Dispatcher.Registry: Registry  "},{"title":"Functions​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#functions","content":" "},{"title":"EvaluateAndRun​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#EvaluateAndRun","content":"&lt;/&gt; Dispatcher:EvaluateAndRun( text: string, executor: Player? , options: { Data: any?, IsHuman: boolean?, }? ) → string-- Command output or error message Runs a command as the given player. Executor is optional when running on the client. If options.Data is given, it will be available on the server with CommandContext.GetData If options.IsHuman is true and this function is called on the client, then the text will be inserted into the window history.  "},{"title":"Run​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#Run","content":"This item only works when running on the client. Client &lt;/&gt; Dispatcher:Run(...: string...) → string Invokes a command programmatically as the local player. Accepts a variable number of arguments, which are all joined with spaces before being run; the command should be the first argument. This function will raise an error if any validations occur, since it's only for hard-coded (or generated) commands.  "},{"title":"GetHistory​","type":1,"pageTitle":"Dispatcher","url":"/Cmdr/beta/api/Dispatcher#GetHistory","content":"This item only works when running on the client. Client &lt;/&gt; Dispatcher:GetHistory() → {string} Returns an array of the user's command history. Most recent commands are inserted at the end of the array. "},{"title":"Cookbook","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/community/cookbook","content":"Cookbook Work in progress We're sorry but this article has yet to be written.","keywords":""},{"title":"Report security vulnerability","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/community/securityreport","content":"","keywords":""},{"title":"A quick note for our users​","type":1,"pageTitle":"Report security vulnerability","url":"/Cmdr/beta/docs/community/securityreport#a-quick-note-for-our-users","content":"It's important that you keep your libraries up to date. We do not monitor, accept reports pertaining to, provide support for, or patch bugs on old versions of Cmdr. If you're experiencing issues, our first recommendation will always be to update Cmdr; this applies even if the update is major (breaking). Making sure you're always running the newest version of Cmdr will give you access to the latest features and bug fixes, and also keep your game safe from any vulnerabilities we find or are alerted to. "},{"title":"Registry","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/Registry","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#types","content":" "},{"title":"HookType​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#HookType","content":"&lt;/&gt; type HookType = &quot;BeforeRun&quot; | &quot;AfterRun&quot;   "},{"title":"ArgumentDefinition​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#ArgumentDefinition","content":"&lt;/&gt; interface ArgumentDefinition { Type: string | TypeDefinition-- The argument type (case sensitive), or an inline TypeDefinition object. Name: string-- The argument name, this is displayed to the user as they type. Description: string?-- A description of what the argument is, this is also displayed to the user. Optional: boolean?-- If this is set to true, then the user can run the command without filling out the value. In which case, the argument will be sent to implementations as nil. Default: any?-- If present, the argument will be automatically made optional, so if the user doesn't supply a value, implementations will receive whatever the value of Default is. } The table definition, usually contained in a CommandDefinition, which 'defines' the argument.  "},{"title":"CommandDefinition​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#CommandDefinition","content":"&lt;/&gt; interface CommandDefinition { Name: string-- The name of the command Aliases: {string}?-- Aliases which aren't part of auto-complete, but if matched will run this command just the same. For example, m might be an alias of announce. Description: string?-- A description of the command, displayed to the user in the help command and auto-complete menu. Group: string?-- This property is intended to be used in hooks, so that you can categorise commands and decide if you want a specific user to be able to run them or not. But the help command will use them as headings. Args: {ArgumentDefinition | (CommandContext) → (ArgumentDefinition)}-- Arguments for the command; this is technically optional but if you have no args, set it to {} or you may experience some interface weirdness. Data: ( CommandContext, ... ) → any-- If your command needs to gather some extra data from the client that's only available on the client, then you can define this function. It should accept the command context and tuple of transformed arguments, and return a single value which will be available in the command with CommandContext:GetData. ClientRun: ( CommandContext, ... ) → string?-- If you want your command to run on the client, you can add this function to the command definition itself. It works exactly like the function that you would return from the Server module. If this function returns a string, the command will run entirely on the client and won't touch the server (which means server-only hooks won't run). If this function doesn't return anything, it will fall back to executing the Server module on the server. Run: ( CommandContext, ... ) → string?-- An older version of ClientRun. There are very few scenarios where this is preferred to ClientRun (so, in other words, don't use it!). These days, Run is only used for some dark magic involving server-sided command objects. }   "},{"title":"TypeDefinition​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#TypeDefinition","content":"&lt;/&gt; interface TypeDefinition { Prefixes: string?-- String containing prefixed union types for this type. This property should omit the inital type, so the string should begin with a prefix character, e.g. Prefixes = &quot;# integer ! boolean&quot; DisplayName: string?-- Overrides the user-facing name of this type in the autocomplete menu. Otherwise, the registered name of the type will be used. Default: ((Player ) → string)?-- Should return the &quot;default&quot; value for this type as a string. For example, the default value of the player type is the name of the player who ran the command. Listable: boolean?-- If true, this will tell Cmdr that comma-separated lists are allowed for this type. Cmdr will automatically split the list and parse each segment through your Transform, Validate, Autocomplete and Parse functions individually, so you don't have to change the logic of your type at all. The only limitation is that your Parse function must return a table, the tables from each individual segment's Parse functions will be merged into one table at the end of the parsing step. The uniqueness of values is ensured upon merging, so even if the user lists the same value several times, it will only appear once in the final table. Transform: ( string, Player ) → T?-- Transform is an optional function that is passed two values: the raw text, and the player running the command. Then, whatever values this function returns will be passed to all other functions in the type (Validate, Autocomplete and Parse). Validate: (T) → ( boolean, string? )-- The Validate function is passed whatever is returned from the Transform function (or the raw value if there is no Transform function). If the value is valid for the type, it should return true. If the value is invalid, it should return two values: false and a string containing an error message. If this function is omitted, anything will be considered valid. ValidateOnce: (T) → ( boolean, string? )-- This function works exactly the same as the normal Validate function, except it only runs once (after the user presses Enter). This should only be used if the validation process is relatively expensive or needs to yield. For example, the playerId type uses this because it needs to call GetUserIdFromNameAsync in order to validate. For the vast majority of types, you should just use Validate instead. Autocomplete: (T) → ( {string}, {IsPartial: boolean?}? )?-- Should only be present for types that are possible to be auto-completed. It should return an array of strings that will be displayed in the auto-complete menu. It can also return a second value, containing a dictionary of options (currently, IsPartial: if true then pressing Tab to auto-complete won't continue onwards to the next argument.) Parse: (T) → any-- Parse is the only required function in a type definition. It is the final step before the value is considered finalised. This function should return the actual parsed value that will be sent to implementations. } The table definition, contained in an ArgumentDefinition or registered, which 'defines' the argument. "},{"title":"Properties​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#properties","content":" "},{"title":"Cmdr​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#Cmdr","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Registry.Cmdr: Cmdr | CmdrClient A reference to Cmdr. This may either be the server or client version of Cmdr depending on where the code is running. "},{"title":"Functions​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#functions","content":" "},{"title":"RegisterType​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterType","content":"&lt;/&gt; Registry:RegisterType( name: string,-- The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit. typeObject: TypeDefinition ) → () Registers a type on the current realm (server/client), this function should be called from within the type definition ModuleScript.  "},{"title":"RegisterTypePrefix​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterTypePrefix","content":"&lt;/&gt; Registry:RegisterTypePrefix( name: string,-- The name of the type. union: string-- The string should omit the initial type name, so this string should begin with a prefix character, e.g. # integer ! boolean ) → () Registers a Prefixed Union Type string on the current realm (server/client), this function should be called from within the type definition ModuleScript. If there are already type prefixes for the given type name, they will be concatenated. This allows you to add prefixes to default types, like players.  "},{"title":"RegisterTypeAlias​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterTypeAlias","content":"&lt;/&gt; Registry:RegisterTypeAlias( name: string,-- The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit. alias: string-- The string should include the initial type name, e.g. string # integer ! boolean ) → () Allows you to register a name which will be expanded into a longer type which can be used as a command argument type. For example, if you register the alias stringOrNumber it could be interpreted as string # number when used.  "},{"title":"RegisterTypesIn​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterTypesIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterTypesIn(container: Instance ) → () Registers all types from within a container on both the server and client.  "},{"title":"RegisterHooksIn​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterHooksIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterHooksIn() → () Registers all hooks from within a container on both the server and client. If you want to add a hook only on the server or client – e.g. for logging – then you should use the Register.RegisterHook method instead.  "},{"title":"RegisterCommand​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterCommand","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterCommand( commandScript: ModuleScript , commandServerScript: ModuleScript? , filter: (CommandDefinition → boolean)?-- If present, will be passed a command definition which will then only be registered if the function returns true. ) → () Registers a command definition and its server equivalent. Handles replicating the definition to the client.  "},{"title":"RegisterCommandsIn​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterCommandsIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterCommandsIn( container: Instance , filter: ((CommandDefinition) → boolean)?-- If present, will be passed a command definition which will then only be registered if the function returns true. ) → () Registers all commands from within a container on both the server and client. Module scripts which include Server in their name will not be sent to the client.  "},{"title":"RegisterDefaultCommands​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterDefaultCommands","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterDefaultCommands(arrayOrFunc: {string} | (CommandDefinition) → boolean | nil) → () Registers the default commands on both the server and client. The optional arrayOrFunc parameter can be provided with: an array of strings — this will limit registration to only commands which have their Group property set to this a function which takes in a CommandDefinition and returns a boolean — only if true is returned will the command be registered  "},{"title":"GetCommand​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetCommand","content":"&lt;/&gt; Registry:GetCommand(name: string) → CommandDefinition? Returns the CommandDefinition from the given name, or nil if no command is found. Command aliases are also accepted.  "},{"title":"GetCommands​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetCommands","content":"&lt;/&gt; Registry:GetCommands() → {CommandDefinition} Returns an array of all registers commands, not including aliases.  "},{"title":"GetCommandNames​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetCommandNames","content":"&lt;/&gt; Registry:GetCommandNames() → {string} Returns an array of containing the names of all registered commands, not including aliases.  "},{"title":"GetTypeNames​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetTypeNames","content":"&lt;/&gt; Registry:GetTypeNames() → {string} Returns an array of containing the names of all registered types, not including aliases.  "},{"title":"GetType​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetType","content":"&lt;/&gt; Registry:GetType(name: string) → TypeDefinition? Returns the type definition from the given name, or nil if no argument is found.  "},{"title":"GetTypeName​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetTypeName","content":"&lt;/&gt; Registry:GetTypeName(name: string) → TypeDefinition | string Returns a type name taking aliases into account. If there is no alias, the name parameter is simply returned as a pass through.  "},{"title":"RegisterHook​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#RegisterHook","content":"&lt;/&gt; Registry:RegisterHook( hookName: HookType, callback: (CommandContext) → string?,-- returns nil for ok, string (errorText) for cancellation priority: number-- If unspecified, the priority will default to 0. ) → () Registers a hook on the current realm (server/client). This should probably be ran on the server or in a hook module script, but can also work on the client. Hooks run in order of priority from lowest (running first) to highest.  "},{"title":"GetStore​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetStore","content":"&lt;/&gt; Registry:GetStore(name: string) → table Returns a table saved with the given name. Always returns the same table on subsequent calls. Useful for commands that require persistent state, like bind or ban. This is the same as CommandContext.GetStore.  "},{"title":"GetCommandsAsStrings​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#GetCommandsAsStrings","content":"deprecated in v1.8.0 &lt;/&gt; This was deprecated in v1.8.0 This method was renamed to GetCommandNames in v1.8.0. The old name exists for backwards compatibility and should not be used for new work. Registry:GetCommandsAsStrings() → ()   "},{"title":"AddHook​","type":1,"pageTitle":"Registry","url":"/Cmdr/beta/api/Registry#AddHook","content":"deprecated in v1.1.2 &lt;/&gt; This was deprecated in v1.1.2 This method was renamed to RegisterHook in v1.1.2. The old name exists for backwards compatibility and should not be used for new work. Registry:AddHook( hookName: HookType, callback: (CommandContext) → string?,-- returns nil for ok, string (errorText) for cancellation priority: number-- If unspecified, the priority will default to 0. ) → ()  "},{"title":"Customising the interface","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/advanced/customisinginterface","content":"","keywords":""},{"title":"Duplicate ScreenGui​","type":1,"pageTitle":"Customising the interface","url":"/Cmdr/beta/docs/advanced/customisinginterface#duplicate-screengui","content":"You should note that if you have CharacterAutoLoads set to false and you load CmdrClient before StarterGui loads (which is on the first character spawn) then you will end up with two Cmdr ScreenGuis. This normally is not an issue, but if you're also customising the Cmdr interface by hooking into PlayerGui.Cmdr then this could be problematic. You can mitigate this issue by refraining from requiring CmdrClient until after PlayerGui has loaded, but this will create a delay in users being able to access Cmdr until after their character has spawned for the first time. Alternatively, you could: Delete Cmdr from StarterGui on the server, after you've required the Cmdr serverOn the client, load your modified copy of Cmdr ScreenGui into PlayerGui (you can skip this step if you only want the default ScreenGui)And then, once you've inserted the gui, require CmdrClient "},{"title":"Contributing","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/contribute/","content":"Contributing Work in progress We're sorry but this article has yet to be written.","keywords":""},{"title":"Util","type":0,"sectionRef":"#","url":"/Cmdr/beta/api/Util","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#functions","content":" "},{"title":"MakeDictionary​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeDictionary","content":"&lt;/&gt; Util.MakeDictionary(array: {any}) → {[any]: true} Takes an array and flips its values into dictionary keys with value of true.  "},{"title":"DictionaryKeys​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#DictionaryKeys","content":"&lt;/&gt; Util.DictionaryKeys(dict: {[any]: any}) → {any} Takes a dictionary and returns its keys.  "},{"title":"MakeFuzzyFinder​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeFuzzyFinder","content":"&lt;/&gt; Util.MakeFuzzyFinder(setOrContainer: any) → ( string, boolean?, boolean? ) → string Returns a function that is a fuzzy finder for the specified set or container. Can pass an array of strings, array of instances, array of EnumItems, array of dictionaries with a Name key or an instance (in which case its children will be used). Exact matches will be inserted in the front of the resulting array.  "},{"title":"GetNames​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#GetNames","content":"&lt;/&gt; Util.GetNames(instances: any) → {string} Takes an array of instances (or anything with a Name property) and maps them into an array of their names. If no Name property is present, then tostring will be called instead.  "},{"title":"SplitStringSimple​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#SplitStringSimple","content":"&lt;/&gt; Util.SplitStringSimple( input: string, sep: string? ) → {string} Splits a string using a simple separator (no quote parsing)  "},{"title":"ParseEscapeSequences​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#ParseEscapeSequences","content":"&lt;/&gt; Util.ParseEscapeSequences(text: string) → string Parses escape sequences into their fully qualified characters  "},{"title":"EncodeEscapedOperator​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#EncodeEscapedOperator","content":"&lt;/&gt; Util.EncodeEscapedOperator( text: string, op: string ) → string No description.  "},{"title":"EncodeEscapedOperators​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#EncodeEscapedOperators","content":"&lt;/&gt; Util.EncodeEscapedOperators(text: string) → string No description.  "},{"title":"SplitString​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#SplitString","content":"&lt;/&gt; Util.SplitString( text: string, max: number ) → {string} Splits a string by space but taking into account quoted sequences which will be treated as a single argument.  "},{"title":"MashExcessArguments​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MashExcessArguments","content":"&lt;/&gt; Util.MashExcessArguments( arguments: {string}, max: number ) → {string} Takes an array of arguments and a max value. Any indicies past the max value will be appended to the last valid argument.  "},{"title":"TrimString​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#TrimString","content":"&lt;/&gt; Util.TrimString(str: string) → string Trims whitespace from both sides of a string.  "},{"title":"GetTextSize​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#GetTextSize","content":"&lt;/&gt; Util.GetTextSize( text: string, label: TextLabel , size: Vector2? ) → Vector2  Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.  "},{"title":"MakeEnumType​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeEnumType","content":"&lt;/&gt; Util.MakeEnumType( name: string, values: any ) → TypeDefinition Makes an Enum type.  "},{"title":"ParsePrefixedUnionType​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#ParsePrefixedUnionType","content":"&lt;/&gt; Util.ParsePrefixedUnionType( typeValue: string, rawValue: string ) → ( string?, string?, string? ) Parses a prefixed union type argument (such as %Team)  "},{"title":"MakeListableType​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeListableType","content":"&lt;/&gt; Util.MakeListableType( type: TypeDefinition, override: table ) → TypeDefinition Creates a listable type from a singular type  "},{"title":"RunCommandString​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#RunCommandString","content":"&lt;/&gt; Util.RunCommandString( dispatcher: Dispatcher, commandString: string ) → string?-- output from Dispatcher:EvaluateAndRun as a string Creates a listable type from a singular type  "},{"title":"RunEmbeddedCommands​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#RunEmbeddedCommands","content":"&lt;/&gt; Util.RunEmbeddedCommands( dispatcher: Dispatcher, str: string ) → string Runs embedded commands and replaces them  "},{"title":"SubstituteArgs​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#SubstituteArgs","content":"&lt;/&gt; Util.SubstituteArgs( str: string, replace: string ) → string Replaces arguments in the format $1, $2, $something with whatever the given function returns for it.  "},{"title":"MakeAliasCommand​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeAliasCommand","content":"&lt;/&gt; Util.MakeAliasCommand( name: string, commandString: string ) → CommandDefinition Creates an alias command, should only be used on the client.  "},{"title":"MakeSequenceType​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#MakeSequenceType","content":"&lt;/&gt; Util.MakeSequenceType(options: { Parse: function?, Constructor: function?, TransformEach: function?, ValidateEach: function?, Prefixes: {string}?, Length: number? }) → ArgumentDefinition Makes a type that contains a sequence, e.g. Vector3 or Color3 For options, one of Constructor or Parse is required  "},{"title":"SplitPrioritizedDelimeter​","type":1,"pageTitle":"Util","url":"/Cmdr/beta/api/Util#SplitPrioritizedDelimeter","content":"&lt;/&gt; Util.SplitPrioritizedDelimeter( text: string, delimiters: {string} ) → {string}? Splits a string by a single delimeter chosen from the given set. The first matching delimeter from the set becomes the split character. "},{"title":"Network event handlers","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/networkeventhandlers","content":"Network event handlers Some commands that run on the server might need to also do something on the client, or on every client. Network event handlers are callback functions that you can set to run when a server command sends a message back to the client. Only one handler can be set to a certain event at a time, so it's possible to change the handler for a specific event without needing to re-implement the entire command yourself. For example, consider the default announce command, which creates a message on every player's screen. By default, this creates a system chat message with the given text, because Cmdr has a default event handler for the &quot;Message&quot; event, which the announce command broadcasts. If you wanted to display announcements some other way, you could just override the default event handler: CmdrClient:HandleEvent(&quot;Message&quot;, function (text, player) print(&quot;Announcement from&quot;, player.Name, text) end) You can send events from your own commands on the server (or to the local player if in a client-only command) by using context:SendEvent(player, ...) and context:BroadcastEvent(...). The built-in context:Reply(text) method actually uses SendEvent under the hood, whose default handler on the client (AddLine) is set to just add a new line to the console window with the given text.","keywords":""},{"title":"Set-up","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/setup","content":"","keywords":""},{"title":"Modifying the source code​","type":1,"pageTitle":"Set-up","url":"/Cmdr/beta/docs/setup#modifying-the-source-code","content":"Do not modify the source code Please do not modify the source code of Cmdr for your game. Instead, use its API to customise the behaviour you want. Modifying the source code makes it much harder for you to receive future updates. There shouldn't be any reason why you need to modify the source code of Cmdr (unless you're adding a new feature or fixing a bug). If there's something you think we're missing, please open an issue. Modifying the source code also includes putting your commands within Cmdr's BuiltInCommands folder; don't do it. You should never touch the Cmdr library or any of its components outside of code. "},{"title":"Server setup​","type":1,"pageTitle":"Set-up","url":"/Cmdr/beta/docs/setup#server-setup","content":"You should create a folder to keep your commands inside and then register them on the server. You only need to register commands, types and hooks on the server: Cmdr will automatically handle replication for you. There is no need to modify the actual Cmdr library itself. -- This is a script you would create in ServerScriptService, for example local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local Cmdr = require(path.to.Cmdr) -- e.g. ServerScriptService.Packages.Cmdr Cmdr.Registry:RegisterDefaultCommands() -- Optional: This loads the default set of commands that Cmdr comes with. -- Cmdr.Registry:RegisterCommandsIn(ServerScriptService.CmdrCommands) -- Optional: Register commands from your own folder. -- You can also register types or hooks here: read on or check the API reference!  The Cmdr object is the main server singleton. The Registry is used on both the client and server, and it keeps track of all the commands, types and hooks that Cmdr knows about. Cmdr will automatically create and insert into StarterGui its console interface (called Window). If you'd like to (optionally) customise the look of the Window, we have a guide on this in our Advanced section. Cmdr will also insert into ReplicatedStorage the CmdrClient module. On top of being the client entry point (read on below!), this module also houses stuff for internal use, like replication (any commands, types and hooks the client needs to know about) and networking. You're not done yet! Client setup is also required, you need to register Cmdr on the server and client for it to load. Keep going! ↓ "},{"title":"Client setup​","type":1,"pageTitle":"Set-up","url":"/Cmdr/beta/docs/setup#client-setup","content":"From the client, you'll need to require the CmdrClient module. Cmdr will place CmdrClient into ReplicatedStorage automatically, no action is required from you. This module includes things used by Cmdr internally, but also provides you - the developer - with methods to customise and tweak Cmdr. -- This is a local/client script you would create in StarterPlayerScripts, for example local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Cmdr = require(ReplicatedStorage:WaitForChild(&quot;CmdrClient&quot;)) -- Optional. Configurable, and you can choose multiple keys Cmdr:SetActivationKeys({ Enum.KeyCode.F2 }) -- You can call any extra methods here, like SetPlaceName, or access the registry to register a hook on the client only (if you want to!)  Activation keys are used to show or hide Cmdr. By default, this is just F2 but you can have as many or as few keys as you'd like (even none). "},{"title":"Next steps​","type":1,"pageTitle":"Set-up","url":"/Cmdr/beta/docs/setup#next-steps","content":"By now, Cmdr is up and running, and will work fine in studio. However, you'll probably want to write your own commands and to run any commands in a live server, you must create a BeforeRun hook. If you ever need help, you can check the support page. "},{"title":"Commands","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/commands","content":"","keywords":""},{"title":"Command data​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#command-data","content":"If you need to gather some data from the client before the command runs, you can create a Data function in your command. This function will run on the client, and whatever is returned from it will be available with context:GetData() in the command implementation. As an example, you might want to know the local player's current mouse world position in a server command. This can be achieved by returning LocalPlayer:GetMouse().Hit.Position from the Data function, then using context:GetData() to get the Vector3. context:GetData() will work on both client and server commands. "},{"title":"Client commands​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#client-commands","content":"It is possible to have commands that run on the client exclusively or both. If you want your command to run on the client, you can add a ClientRun function to the command definition itself. It works exactly like the function that you would return from the Server module. If using ClientRun, having a Server module associated with this command is optional. If your ClientRun function returns a string, the command will run entirely on the client and won't touch the server at all (which means server-only hooks won't run). If this function doesn't return anything, it will then execute the associated Server module implementation on the server (including any server-sided hooks). caution If the ClientRun function is present and there isn't a Server module for this command then you must return a string from the ClientRun function. "},{"title":"Execution order​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#execution-order","content":"Including Hooks, the full execution order is: BeforeRun hook on client.Data function on client.ClientRun function on client.BeforeRun hook on server. *Server command implementation returned from Server module. *AfterRun hook on server. *AfterRun hook on client. * Only runs if ClientRun isn't present or ClientRun returns nil. You should be aware that an exploiter can, in theory, manipulate or bypass any client parts of execution. This isn't an issue though as exploiters can already do anything that's possible for a client component to do, but you should keep it in mind when designing your systems. "},{"title":"Default commands​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#default-commands","content":"Possibly outdated We've not reviewed this section for a while, it's possible that this information may be out of date. If you run Cmdr.Registry:RegisterDefaultCommands(), these commands will be available with the following Groups: Group: DefaultAdmin: announce (m), bring, kick, teleport (tp), kill, respawn, to Group: DefaultDebug: blink (b), thru (t), position, version, fetch, get-player-place-instance, uptimeGroup: DefaultUtil: alias, bind, unbind, run (&gt;), runif, echo, hover, replace (//, gsub), history, me, var, var=, json-array-encode, json-array-decode, resolve, len, pick, rand, edit, goto-place Group: Help: help "},{"title":"Registering a subset of the default commands​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#registering-a-subset-of-the-default-commands","content":"If you only want some, but not all, of the default commands, you can restrict the commands that you register in two ways. Pass an array of groups to the RegisterDefaultCommands function: Cmdr.Registry:RegisterDefaultCommands({&quot;Help&quot;, &quot;DefaultUtil&quot;})Pass a filter function that accepts a CommandDefinition and either returns true or false: Cmdr.Registry:RegisterDefaultCommands(function(cmd) return #cmd.Name &lt; 6 -- This is absurd... but possible! end)  More practically, you could use this to create an allow list of default commands you want in your game, and ones you don't. "},{"title":"Argument value operators​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#argument-value-operators","content":"Instead of typing out an entire argument, you can insert the following operators as a shorthand. Operator\tMeaning\tListable types only.\tDefault value for the type\tNo ?\tA random value from all possible values\tNo *\tA list of all possible values\tYes **\tAll possible values minus the default value.\tYes ?N\tN random values picked from all possible values\tYes &quot;All possible values&quot; is determined automatically by using the values that are displayed in the autocomplete menu when you haven't typed anything for that argument yet. If you want Cmdr to interpret the operator as literal text, you can escape these operators by inserting a \\ before them. For example: \\* will be interpreted as a literal *. "},{"title":"Example​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#example","content":"For the players type, this is the meaning of the operators: Operator\tMeaning.\t&quot;me&quot;, or the player who is running the command. ?\tA random single player. *\tAll players. **\t&quot;others&quot;, or all players who aren't the player running the command. ?N\tN random players. So: kill * kills all players, while kill ** kills all players but you. "},{"title":"resolve command​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#resolve-command","content":"The resolve command can be used to retrieve the true value of these operators as a list. It takes a type and an operator as arguments, and returns the list as a string. Examples: Input\tOutputresolve players .\tPlayer1 resolve players *\tPlayer1,Player2,Player3,Player4 resolve players **\tPlayer2,Player3,Player4 resolve players ?\tPlayer3 "},{"title":"Prefixed union types​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#prefixed-union-types","content":"An argument can be allowed to accept a different type when starting with a specific prefix. The most common example of this is with the players type, which when prefixed with % allows the user to select players based on team, rather than name. These can be defined on a per-argument basis, so that your commands can accept many types of arguments in a single slot. Under the Args section of command definition, each argument has a Type key. For arguments that accept only a single type, it would look like Type = &quot;string&quot;. If we also wanted to accept a number when the user prefixes the argument with #, we could change it to: Type = &quot;string # number&quot;. Then, if the user provided #33 for this argument, your function would be delivered the number value 33 in that position. This is infinitely expandable, and you can include as many prefixed union types as you wish: Type = &quot;string # number @ player % team&quot;, etc. Remember that there must be a space between the symbol and the type. Some default types automatically have a prefixed union type applied to them, because they would both resolve to the same type in the end. For example, whenever you define an argument of type players, under the hood this is perceived as players % teamPlayers. (teamPlayers is a type that matches based on team name, but resolves to an array of Players: the same thing that the normal players type would resolve with.) Here is a list of automatic prefixed union types: Type\tUnionplayers\tplayers % teamPlayers playerId\tplayerId # integer playerIds\tplayerIds # integers brickColor\tbrickColor % teamColor brickColors\tbrickColors % teamColors color3\tcolor3 # hexColor3 ! brickColor3 color3s\tcolor3s # hexColor3s ! brickColor3s "},{"title":"Dynamic arguments and inline types​","type":1,"pageTitle":"Commands","url":"/Cmdr/beta/docs/commands#dynamic-arguments-and-inline-types","content":"Dynamic types are included within a command definition's Args array, they are functions which take in the command context and then return an ArgumentDefinition. Despite being called inline types, they are not types themselves. This is as opposed to static arguments, which are ArgumentDefinitions rather than functions. Inline types allow developers to save time adding bespoke types for individual commands, or types which need to vary depending on the command context. For example, you could have an allowlist command which takes an enum of add or remove as its first argument, the second argument then could be a playerId (for add) or a custom allowlistPlayer type (for remove) depending on the first argument. Inline types can be and usually are paired with dynamic types. Inline types are not registered (so their names don't need to be unique) and take advantage of the fact that the Type key in an argument definition can also be a TypeDefinition itself. This is most commonly used with enum types: allowlist.lua return { Name = &quot;allowlist&quot;, Aliases = {}, Description = &quot;Add or remove a player from the allow list.&quot;, Group = &quot;Admin&quot;, Args = { -- This is an example of a dynamic inline type function(context) return { Type = context.Cmdr.Util.MakeEnumType(&quot;option&quot;, {&quot;add&quot;, &quot;remove&quot;}), Name = &quot;Action&quot;, Description = &quot;Add or remove&quot;, } end, -- This is an example of a dynamic argument function(context) local action = context:GetArgument(1):GetValue() return { Type = if action == &quot;add&quot; then `playerId` else `allowlistPlayer`, Name = &quot;Player&quot;, Description = `The player to {action} from the allow list.`, } end, }, }  "},{"title":"Updating","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/updating","content":"Updating Work in progress We're sorry but this article has yet to be written.","keywords":""},{"title":"Hooks","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/hooks","content":"","keywords":""},{"title":"BeforeRun​","type":1,"pageTitle":"Hooks","url":"/Cmdr/beta/docs/hooks#beforerun","content":"The callback is passed the CommandContext for the relevant command. The hooks are the last thing to run before the command itself, so all properties are available. This hook can be used to interrupt command execution (useful for permissions) by returning a string. The returned string will replace the command output on the executing user's screen. If the callback returns nothing (nil or no return), then the command will run normally. Security Warning Commands will be blocked from running in a live game unless you register at least one BeforeRun hook. As a quick way to register hooks on both the server and the client, you can make a folder for your hooks, with module scripts in them which return a function. Similar to Types, if you call Cmdr.Registry:RegisterHooksIn(yourFolderHere) from the server, Cmdr will load all ModuleScripts in the folder on the server and the client, so you only need to write your code once. A ModuleScript inside your hooks folder. return function (registry) registry:RegisterHook(&quot;BeforeRun&quot;, function(context) if context.Group == &quot;DefaultAdmin&quot; and context.Executor.UserId ~= game.CreatorId then return &quot;You don't have permission to run this command&quot; end end) end  "},{"title":"AfterRun​","type":1,"pageTitle":"Hooks","url":"/Cmdr/beta/docs/hooks#afterrun","content":"The AfterRun hook runs directly after a command is run. The callback is also passed a CommandContext, but the Response property is now available, which is the response from the command implementation (what would normally be displayed after running the command). If this callback returns a string, then it will replace the normal response on the user's screen. If the callback returns nothing (nil or no return), then the response will be shown normally. This hook is most useful for logging. Since we don't want to add this hook on the client in this example, we can just require the server version of Cmdr and add this hook directly right here (as opposed to what we did in the BeforeRun example, which adds the hook to the client as well): Cmdr.Registry:RegisterHook(&quot;AfterRun&quot;, function(context) print(context.Response) -- see the actual response from the command execution return &quot;Returning a string from this hook replaces the response message with this text&quot; end)  "},{"title":"Execution order​","type":1,"pageTitle":"Hooks","url":"/Cmdr/beta/docs/hooks#execution-order","content":"BeforeRun hook on client.Data function on client.ClientRun function on client.BeforeRun hook on server. *Server command implementation returned from Server module. *AfterRun hook on server. *AfterRun hook on client. * Only runs if ClientRun isn't present or ClientRun returns nil. You should be aware that an exploiter can, in theory, manipulate or bypass any client parts of execution. This isn't an issue though as exploiters can already do anything that's possible for a client component to do, but you should keep it in mind when designing your systems. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/installation","content":"","keywords":""},{"title":"Model file (recommended)​","type":1,"pageTitle":"Installation","url":"/Cmdr/beta/docs/installation#model-file-recommended","content":"You can visit the latest release page. At the bottom of the page, you'll find an &quot;Assets&quot; section, then download Cmdr.rbxm If you're using Roblox Studio: You can either: drag or drop the Cmdr.rbxm file into the viewport (central window)select the Model tab, then under the Advanced section click Model. Then, navigate to the Cmdr.rbxm file and click Open Make sure you move the Cmdr ModuleScript to wherever you want it (as above, we recommend you keep it on the server)Proceed to Setup If you're using Rojo, you can either add the Cmdr.rbxm file to your project file (usually called default.project.json), or put the Cmdr.rbxm file into a directory that you've got set up to sync already. Rojo's documentation can help you with this. "},{"title":"Wally (recommended) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/Cmdr/beta/docs/installation#wally-recommended-requires-rojo","content":"Cmdr is published on the wally registry as evaera/cmdr; you should be cautious about the potential for malware and only use the official package. You can easily add Cmdr to your project's wally.toml file. If you're experiencing difficulties, Wally's documentation can help. We recommend adding Cmdr to the 'server realm', you can do this by putting it under the server-dependencies section. This'll put it in a ServerPackages folder (which you'll then need to sync into your game using Rojo). [server-dependencies] Cmdr = &quot;evaera/cmdr@^1.9.0&quot;  Make sure you check what the latest version is. The caret (^) will tell Wally to automatically upgrade to the newest compatible version if available, which we recommend doing. "},{"title":"Submodule (advanced) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/Cmdr/beta/docs/installation#submodule-advanced-requires-rojo","content":"If your project is using Rojo and Git, then you can use Git Submodules to include Cmdr into your project, and then sync it into your game using Rojo. This will include a lot of unnecessary files into your project though, like the website and documentation, so you should make sure you only pull or sync the Cmdr directory (which is the library source code). We recommend 'pinning' to the latest version's tag, rather than using the master branch. This is because pre-release versions may have unexpected bugs, glitches or changes, and we may not be able to offer you support unless you're using the latest released version. "},{"title":"Manual (not recommended) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/Cmdr/beta/docs/installation#manual-not-recommended-requires-rojo","content":"Using git clone or GitHub's Download button, you can download a copy of the source code and then take the Cmdr directory and sync this into your place. We recommend downloading the latest version rather than using the master branch. This is because pre-release versions may have unexpected bugs, glitches or changes, and we may not be able to offer you support unless you're using the latest released version. "},{"title":"Roblox models (not supported)​","type":1,"pageTitle":"Installation","url":"/Cmdr/beta/docs/installation#roblox-models-not-supported","content":"Cmdr is not published to the Roblox creator marketplace. Owing to the prevalence of malware, you should not use any publish of Cmdr on the Roblox library, and instead use one of the above installation methods. If you're experiencing difficulties and need help, then you can find advice on getting help in the Introduction page. "},{"title":"Meta-commands","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/metacommands","content":"","keywords":""},{"title":"Embedded commands​","type":1,"pageTitle":"Meta-commands","url":"/Cmdr/beta/docs/metacommands#embedded-commands","content":"Sub-commands may be embedded inside command strings, in the format ${command arg1 arg2 arg3}. These sub-commands are evaluated just before the command string is run, and are run every time the command string runs. They evaluate to whatever the command returns as output. Embedded commands are nestable: run echo ${run echo ${echo hello}!} (displays hello!). We use run here instead of just running echo directly, because embedded commands are only evaluated in the preprocess step of commands that use command strings (which is only run, alias, and bind). By default, if the evaluated command output has a space in it, the return value will be encapsulated in quote marks so that the entire value is perceived as one argument to Cmdr. In cases where it's desirable for Cmdr to parse each word as a separate argument, you can use use a literal syntax: run teleport ${{&quot;echo first second&quot;}​} (in this example, &quot;first&quot; and &quot;second&quot; would then become the first and second arguments to the teleport command, instead of the first argument being &quot;first second&quot;) "},{"title":"Run​","type":1,"pageTitle":"Meta-commands","url":"/Cmdr/beta/docs/metacommands#run","content":"Run is the simplest of the bunch, and does right what it says on the tin. It runs whatever text you give it immediately as a command. This is useful, because it evaluates embedded commands within the command string before running. run ${{&quot;echo kill me&quot;}}  Commands can contain more than one distinct command, delimited by &amp;&amp;. This can be escaped by adding an additional ampersand, for example: &amp;&amp;&amp;. You can escape an additional level by adding more. &amp;&amp;&amp;&amp; is a two level deep escape. When using &amp;&amp;, you can access the previous command's output by using the || slot operator. For example run echo evaera &amp;&amp; kill || would cause evaera to die. The run command has a single-character alias, &gt;, which can also be used to invoke it. "},{"title":"Bind​","type":1,"pageTitle":"Meta-commands","url":"/Cmdr/beta/docs/metacommands#bind","content":"Bind is a command that allows you to run a certain command string every time some event happens. The default bind type is by user input (mouse or keyboard input), but you can also bind to other events. This is very powerful: you could define a command, like cast_ability, which casts a certain move in your game. Then, you could have a keybindings menu that allows the user to rebind keys, and whenever they do, it runs CmdrClient:Run(&quot;bind&quot;, keyCode.Name, &quot;cast_ability&quot;, abilityId) in the background. By separating the user input from our hypothetical ability code, our code is made more robust as we can now trigger abilities from a number of possible events, in addition to the bound key. If you prefix the first argument with @, you can instead select a player to bind to, which will run this command string every time that player chats. You can get the chat text by using $1 in your command string. In the future, you will be able to bind to network events as described in the previous section by prefixing the first argument with !. The unbind command can be used to unbind anything that bind can bind. "},{"title":"Alias​","type":1,"pageTitle":"Meta-commands","url":"/Cmdr/beta/docs/metacommands#alias","content":"The alias command lets you create a new, single command out of a command string. Alias commands can contain more than one distinct command, delimited by &amp;&amp;. You can also accept arguments from the command with $1 through $5. alias farewell announce Farewell, $1! &amp;&amp; kill $1  Then, if we run farewell evaera, it would make an announcement saying Farewell, evaera! and then kill the player called evaera. As another example, you could create a command that killed anyone your mouse was currently hovering over like so: alias pointer_of_death kill ${hover}  "},{"title":"Types and Descriptions​","type":1,"pageTitle":"Meta-commands","url":"/Cmdr/beta/docs/metacommands#types-and-descriptions","content":"You can optionally provide types, names, and descriptions to your alias arguments, like so: $1{type|Name|Description here}. For example: alias goodbye kill $1{player|Player|The player you want to kill.}  Name and Description are optional. These are all okay: alias goodbye kill $1{player}alias goodbye kill $1{player|Player}alias goodbye kill $1{player|Player|The player you want to kill.} Additionally, you can supply a description for the command itself: alias &quot;goodbye|Kills a player.&quot; kill $1{player|Player|The player you want to kill.}  The double quotes here are used to 'escape' the space, meaning it'll get parsed as part of the first argument. This is common in consoles (shells) outside of Roblox. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/intro","content":"","keywords":""},{"title":"What is Cmdr and who is it for?​","type":1,"pageTitle":"Introduction","url":"/Cmdr/beta/docs/intro#what-is-cmdr-and-who-is-it-for","content":"Cmdr is a console built for the Roblox platform. It's designed to make it easy for developers to write commands and easy for users to run those commands. While originally made to help developers with debugging, Cmdr has been popularised as a general console and command system due to its powerful features and extensible nature. Of course, this doesn't mean that you have to use it for debugging or administration; Cmdr can be used in whatever way works for you. "},{"title":"Why should I use it?​","type":1,"pageTitle":"Introduction","url":"/Cmdr/beta/docs/intro#why-should-i-use-it","content":"Cmdr is exceptionally user friendly thanks to type-safety and intelligent, context-aware auto-complete. This makes a user made aware of typos and mistakes before they even hit enter. Plus, a developer's command implementations doesn't have to check or transform types, you get exactly what you ask for. Unlike other &quot;admin commands&quot; systems on Roblox, Cmdr quietly integrates with your game rather than getting in the way. This makes it super easy to write your own commands or types which 'plug into' your existing code. Plus, Cmdr is incredibly snappy and will do as much work as possible on the client; providing users, especially those with limited connections, quick feedback. Cmdr provides a number of helpful commands and a range of powerful types out of the box, but of course you don't have to use them. We're also working on creating a Cookbook which'll showcase even more helpful commands and cool things you can do with Cmdr. Cmdr also provides meta-commands, empowering users to: create aliases and/or chain commands togetherbind commands to inputs (like key presses)run commands when you join the game (which, in turn, can do the above!) Cmdr has been around for over five years and while it's been continuously improved since, it's stood the test of time and is trusted in games with billions of visits earning millions of dollars worth of revenue. For many developers, Cmdr is their go-to when they need a console system, saving them the potentially hundreds of hours of time it would take to develop their own. "},{"title":"Why shouldn't I use it?​","type":1,"pageTitle":"Introduction","url":"/Cmdr/beta/docs/intro#why-shouldnt-i-use-it","content":"While we think Cmdr is amazing, it may not be right for you if: You have limited Luau knowledge. While Cmdr isn't super complex, it may be difficult for beginners and those with limited programming experience. You'll need to write your own command implementations and permissions yourself; take a look at the How do I get help with Cmdr? section below for more details. Similarly, any features which Cmdr doesn't provide (like bespoke types or logging) you'll also need to write yourself. You want a large set of pre-made (&quot;plug and play&quot;) commands. While Cmdr has a set of built-in commands, these are fairly limited. There are plenty of open source &quot;admin commands&quot; systems which, while we can't comment on their quality, do provide a large number of diverse commands coupled with easy set-up. You may find our Cookbook helpful but it's still fairly limited and you'll need to make the bulk of commands yourself. Mobile support is mission-critical. Cmdr's mobile support isn't perfect and is lacking in some areas. Also, you'll need to add some way for mobile and other non-keyboard users to be able to open the console. First and foremost, Cmdr is a keyboard experience and it has been designed with this in mind. Although, if you think there's any areas that could be improved feel free to open an Issue ticket. "},{"title":"How do I get started?​","type":1,"pageTitle":"Introduction","url":"/Cmdr/beta/docs/intro#how-do-i-get-started","content":"Do not modify the source code Please do not modify the source code of Cmdr for your game. Instead, use its API to customise the behaviour you want. Modifying the source code makes it much harder for you to receive future updates. There shouldn't be any reason why you need to modify the source code of Cmdr (unless you're adding a new feature or fixing a bug). If there's something you think we're missing, please open an issue. Take a look at the Installation guide, you can then continue through our documentation from there. You can also read through the API reference. While we recommend reading the API reference to get a full understanding of Cmdr, it's not required. We recommend against following any tutorials, particularly on YouTube or the DevForum, to set up Cmdr. These tend to be incorrect or outdated. Take a look at the How do I get help with Cmdr? section below for more details on how to get support and what resources are available. "},{"title":"How do I get help with Cmdr?​","type":1,"pageTitle":"Introduction","url":"/Cmdr/beta/docs/intro#how-do-i-get-help-with-cmdr","content":"Luau knowledge — please read! If you don't know how to program with Luau then we recommend you don't use Cmdr. Cmdr is targeted towards those with experience in the Luau language and you will run into bigger problems down the road if you don't know what you're doing. We unfortunately can't 'hand hold' you through things. Setup is a huge, crucial step to determine if you should be using Cmdr or not. It may be a bit frustrating now, but later on if something breaks the frustration will exponentially increase. This is the reason why we tell those who need to touch up on their Luau or programming skills to do so beforehand. Our support channels exist to provide help with Cmdr-specific things, like our API. We cannot answer general Luau questions or help you with a specific command implementation (e.g. &quot;how do I make a fly command?&quot;), although you may find our Cookbook helpful. There are plenty of resources available to help you with Cmdr, such as this website and our Discord server, but we've been made aware of a number of DevForum guides and YouTube videos which provide incorrect or outdated instructions. We recommend you stick to our official resources, especially if you're new to Cmdr. If you decide to use unofficial resources, then the level of support we can provide (for instance in our Discord server) is limited. The Cmdr Discord server has a dedicated cmdr-help channel, which is where we recommend you go to get any support you need. "},{"title":"Types","type":0,"sectionRef":"#","url":"/Cmdr/beta/docs/types","content":"","keywords":""},{"title":"Default value​","type":1,"pageTitle":"Types","url":"/Cmdr/beta/docs/types#default-value","content":"You can specify a &quot;default value&quot; for your type by adding a Default function to it. For example, the default value for the players type is the name of the player who ran the command. The Default function should always return a string, as this is inserted before parsing. For any argument whose type has a default value, you can simply input . and the default value will automatically be used in its place. E.g. kill . "},{"title":"Enum types​","type":1,"pageTitle":"Types","url":"/Cmdr/beta/docs/types#enum-types","content":"Because Enum types are so common, there is a special function that easily lets you create an Enum type. When a command has an argument of this type, it'll always be a string matching exactly one of the strings in the array you define (see below). return function (registry) registry:RegisterType(&quot;place&quot;, registry.Cmdr.Util.MakeEnumType(&quot;Place&quot;, {&quot;World 1&quot;, &quot;World 2&quot;, &quot;World 3&quot;, &quot;Final World&quot;})) end  "}]